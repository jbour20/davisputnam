import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * Backend for my adventure game implementation.
 * Reads in file generated by my Davis-Putnam implementation, interprets
 * the results, and writes the results to the solution file specified in
 * DefaultFiles.java. If a solution was found, results are formatted as a
 * comma-separated list of node names in the order they are visited.
 * Otherwise the text 'NO SOLUTION' is written.
 *
 * @author Jeffrey Bour
 */
public class BackEnd {

  // List of true propositions.
  private final List<Integer> truths;
  // Key provided originally by the frontend.
  private final Map<Integer, String> atomMap;

  BackEnd() {

    truths = new ArrayList<Integer>();
    atomMap = new HashMap<Integer, String>();

  }

  // Start the BackEnd program.
  void go() {

    getTruths(DefaultFiles.DAVIS_PUTNAM_OUTPUT);
    mapAtoms(DefaultFiles.DAVIS_PUTNAM_OUTPUT);

    String result = interpretResults();
    writeToFile(DefaultFiles.SOLUTION, result);

  }

  // First pass: Read in atoms and their values, if a solution was found.
  private void getTruths(DefaultFiles inFile) {

    try {

      BufferedReader br = new BufferedReader(new FileReader(inFile.getFile()));
      String line = br.readLine();

      while (!line.startsWith("0")) {
        String[] tokens = line.trim().split("\\s+");
        if (tokens[1].equals("T")) {
          try {
            Integer val = Integer.parseInt(tokens[0]);
            truths.add(val);
          } catch (NumberFormatException e) {
            // assume input is well-formed...
          }
        }
        line = br.readLine();
      }

      br.close();

    } catch (IOException e) {
      // ignore...
    }

  }

  // Second pass: Read in key originally provided by frontend and store mapping.
  private void mapAtoms(DefaultFiles inFile) {

    try {

      BufferedReader br = new BufferedReader(new FileReader(inFile.getFile()));
      String line = br.readLine();

      // skip lines read previously.
      while (!line.startsWith("0")) {
        line = br.readLine();
      }

      line = br.readLine();

      while (line != null) {
        String[] tokens = line.trim().split("\\s+");
        try {
          Integer val = Integer.parseInt(tokens[0]);
          atomMap.put(val, tokens[1]);
        } catch (NumberFormatException e) {
          // assume input is well-formed...
        }
        line = br.readLine();
      }

      br.close();

    } catch (IOException e) {
      // assume input is well-formed...
    }

  }

  // Look through true atoms (if any exist), and trace the players' location
  // as given by the Davis-Putnam solution.
  private String interpretResults() {

    if (truths.size() == 0) {
      return "NO SOLUTION";
    }

    // Use a TreeMap to order location atoms by time.
    Map<Integer, String> sorted = new TreeMap<Integer, String>();

    for (Integer truth : truths) {

      String atom = atomMap.get(truth);

      // We're only concerned with the position of the player
      // at any given time, so only look for 'At' atoms.
      if (atom.startsWith("At")) {

        int open = atom.indexOf("(");
        int comma = atom.indexOf(",");
        int close = atom.indexOf(")");

        if (open != -1 && comma != -1 && close != -1 &&
            open < comma && comma < close) {

          String node = atom.substring(open + 1, comma);

          try {
            Integer val = Integer.parseInt(atom.substring(comma + 1, close));
            sorted.put(val, node);
          } catch (NumberFormatException e) {
            // ignore...
          }

        }

      }

    }

    return formatResults(sorted);

  }

  // Return a formatted list of node names contained in the TreeMap
  // constructed above.
  private String formatResults(Map<Integer, String> sorted) {

    StringBuilder s = new StringBuilder();
    boolean haveFirst = false;

    for (Map.Entry<Integer, String> entry : sorted.entrySet()) {
      if (haveFirst) {
        s.append(", ");
      }
      s.append(entry.getValue());
      haveFirst = true;
    }

    return s.toString();

  }

  // Write content to specified file.
  private void writeToFile(DefaultFiles outFile, String content) {

    try {
      BufferedWriter bw = new BufferedWriter(new FileWriter(outFile.getFile()));
      bw.write(content);
      bw.close();
    } catch (IOException e) {
      // ignore...
    }

  }

}